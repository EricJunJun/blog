# 过期键删除策略:定时删除、惰性删除或者定期删除
* 定时删除:在设置键的过期时间的同时,创建一个定时器(timer),让定时器在键的过期时间来临时,立即执行对键的删除操作.(主动删除策略)
* 惰性删除:放任键过期不管,但是每次从键空间中获取键时,都检查取得的键是否过期,如果过期的话,就删除该键;如果没有过期,就返回该键.(被动删除策略)
* 定期删除:每隔一段时间,程序就对数据库进行一次检查,删除里面的过期键.至于要删除多少过期键,以及要检查多少个数据库,则由算法决定.(主动删除策略)

# 定期删除
### 定时删除的优点
* 对内存: 通过使用定时器,定时删除策略可以保证过期键会尽可能快地被删除,并释放过期键所占用的内存.

### 定期删除的缺点
* 对CPU时间: 在过期键比较多的情况下,删除过期键这一行为可能会占用相当一部分CPU时间,在内存不紧张但是CPU时间非常紧张的情况下,将CPU时间用在删除和当前任务无关的过期键上,无疑会服务器的响应时间和吞吐量造成影响.
* 创建一个定时器需要用到Redis服务器中的时间事件,而当前时间事件的实现方式——无序链表,查找一个事件的时间复杂度为O(N)——并不能高效地处理大量时间事件.

### 结论
> 要让服务器创建大量的定时器,从而实现定时删除策略,在现阶段来说并不现实.

# 惰性删除
### 惰性删除的优点
* 对CPU时间: 程序只会在取出键时才对键进行过期检查,这可以保证删除过期键的操作只会在非做不可的情况下进行,并且删除的目标仅限于当前处理的键,这个策略不会在删除其他无关的过期键上花费任何CPU时间.

### 惰性删除的缺点
* 对内存: 如果一个键已经过期,而这个键又仍然保留在数据库中,那么只要这个过期键不被删除,它所占用的内存就不会释放.

### 造成内存泄漏
在使用惰性删除策略时,如果数据库中有非常多的过期键,而这些过期键又恰好没有被访问到的话,那么它们也许永远也不会被删除(除非用户手动执行FLUSHDB),我们甚至可以将这种情况看作是一种内存泄漏——无用的垃圾数据占用了大量的内存,而服务器却不会自己去释放它们,这对于运行状态非常依赖于内存的Redis服务器来说,肯定不是一个好消息.

例子:

![例子](https://github.com/gdufeZLYL/blog/blob/master/images/20180512085005.png)

# 定期删除
### 定时删除和惰性删除在单一使用时的缺陷
* 定时删除占用太多CPU时间,影响服务器的响应时间和吞吐量.
* 惰性删除浪费太多内存,有内存泄漏的危险.

### 定期删除策略:定时删除策略和惰性删除策略的一种整合和折中
* 定期删除策略每隔一段时间执行一次删除过期键操作,并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响.
* 除此之外,通过定期删除过期键,定期删除策略有效地减少了因为过期键而带来的内存浪费.

### 定期删除策略的难点:确定删除操作执行的时长和频率
* 如果删除操作执行得太频繁,或者执行的时间太长,定期删除策略就会退化成定时删除策略,以至于将CPU时间过多地消耗在删除过期键上面.
* 如果删除操作执行得太少,或者执行的时间太短,定期删除策略又会和惰性删除策略一样,出现浪费内存的情况.